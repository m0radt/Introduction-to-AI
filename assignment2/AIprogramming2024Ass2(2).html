
<!-- saved from url=(0052)https://www.cs.bgu.ac.il/~shimony/AI2020/AIass2.html -->
<html><head><meta http-equiv="Content-Type" content="text/html; charset=windows-1252">
<title>AI Assignment 2</title>
<link rev="made" href="mailto:webmaster@cs.bgu.ac.il">

</head>

<body>
	<center>
	<h1>Introduction to Artificial Intelligence </h1>
	<h3>Programming Assignment 2</h3>
	</center>
<hr>
	<h2>Cooperating and adversarial agents in the MAPD problem</h2>
<p>
In the second exercise you will be using a simplified version of the environment
simulator from the first assignment, the MAPD problem,
as a platform for implementing <b>intelligent</b>
cooperating and adversarial agents.
The environment is the same as before, except that now we will
assume two normal pickup and delivery agents (perhaps they are employed at competing companies)
who each seek to deliver as many packages as possible.
We will examine settings ranging from cooperative to adversarial.

</p><h3>Game Environment</h3>

<p>
As before, the environment consists of an undirected grid-shaped graph.
As before, an agent can apply 2 types of action: <b>traverse</b> and <b>no-op</b>.
Semantics of the action are as in assignment 1, repeated below.
The traverse action always succeeds if the edge to be traversed is unblocked, and if the target vertex does not contain another agent,
and fails otherwise. A failed action behaves like no-op.
As before, we will assume for simplicity that the agents
take turns at every time unit, thus moving in pseudo parallelism.
The game ends when no more packages can be delivered on time.

</p><h3>Implementation Steps</h3>

<p>
The simulator should query the user about the parameters,
 the type of game (see below) as well as other
initialization parameters. Naturally you may wish to reuse most of the code from assignment 1, which can easily be done if you did a good job
when implementing programming assignment 1. Input file format can be exactly 
the same as in programming assignment 1.

</p><p>
After the above initialization, the simulator should run each agent in turn,
performing the actions returned by the agents, and update the world
accordingly. Additionally, the simulator should be capable of displaying the
world status after each step, with the appropriate state of the agents and
their score.  The agent <bf>individual</bf> score ISi is the number of packages it has delivered on time.
The agent <bf>total</bf> score TSi that it tries to optimize depends on the type of game, below.
Each agent program (a function) works as follows. 
The agent is called by the simulator, together with
a set of observations (or pointer to the state of the world). The agent returns a move to be carried out in the 
current world state. The agent is allowed to keep an internal state
if needed.
In this assignment, the agents can observe the entire state of the world.

You should support the following types of games:
</p><ol>
<li> Adversarial (zero sum game): each agent aims to maximize its own individual score 
(number of packages deliverd on time) minus the opposing agent's score. That is, TS1=IS1-IS2 and TS2=IS2-IS1.
Here you should implement an "optimal" agent, using mini-max, with alpha-beta pruning.
</li><li> A semi-cooperative game: each agent tries to maximize its own individual score. The agent disregards the
other agent score, except that ties are broken <b>cooperatively</b>. THat is, TS1=IS1, breaking ties in favor of greater IS2.
</li><li> A <b>fully cooperative</b> game: both agents aim to maximize the sum of individual scores, so TS1=TS2=IS1+IS2.
</li></ol>

<p>
Since the game tree will usually be too big to reach terminal positions
in the search, you should also implement a cutoff, and a heuristic static
evaluation function for each game. You may use the same heuristic for
all games, if you think this is justified.

</p><h2>Deliverables</h2>

<p>
The program and code sent to the grader, by e-mail or
otherwise as specified by the grader, a printout of the code and results.
You need to show example scenarios where the optimal behavior differs for
the 3 kinds of games (you will need to make the example
scenarios  <b>very</b> small 
in order to be able to reach terminal states in the search).
A description of your heuristic evaluation functions and their 
rationale.
Set up a time for frontal grading checking of the delivered assignment,
in which both members of each team must demonstrate at least <b>some</b>
familiarity with their program.

</p><p>

Due date: TBA, 2024. This assignment may be done in pairs.



</p></body></html>